<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Monitor</title>
    <style>
        body {
            font-family: monospace;
            background: #1a1a1a;
            color: #fff;
            /* padding: 20px; */
            margin: 0;
            max-width: 100%;
        }
        h1 {
            /* font-size: clamp(1.5rem, 4vw, 2.5rem); */
            text-align: center;
        }
        #output {
            border: 1px solid #333;
            padding: 10px;
            margin: 10px 0;
            min-height: 400px;
            background: #000;
            width: 100%;
           
            max-width: 1200px;
            margin: 0 auto;
            box-sizing: border-box;
            overflow-x: auto;
        }
        .controls {
            margin: 10px 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #444;
            cursor: pointer;
            min-width: 150px;
            font-size: clamp(0.875rem, 2vw, 1rem);
        }
        button:hover {
            background: #3a3a3a;
        }
        .green { color: #4CAF50; }
        .red { color: #f44336; }
        .yellow { color: #ffeb3b; }
        .blue { color: #2196F3; }
    
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            button {
                width: 100%;
                margin: 2px;
            }
            #output {
                min-height: 300px;
            }
        }
    </style>    
</head>
<body>
    <div style="text-align: center; margin: 20px 0; padding: 10px; background: #2a2a2a; border-radius: 8px; max-width: 800px; margin: 0 auto;">
        <p style="margin: 5px 0; font-size: 0.9em; color: #888;">A real-time trading monitor with predictive analysis</p>
        <p style="margin: 5px 0; font-size: 1.1em; color: #4CAF50;">Currently Monitoring: EUR/USD Trading Pair</p>
        <p style="margin: 5px 0; font-size: 0.8em; color: #ffeb3b;">Analyzing 1-minute intervals for optimal trading signals</p> 
         <p style="margin: 0; color: #2196F3;">Created by Tadeo Sauceda</p>
    </div>
    <h1>Trading Monitor</h1>
    <div class="controls">
        <button onclick="onDemandPrediction()">Get Prediction</button>
        <button onclick="toggleMonitoring()" id="monitorBtn">Start Monitoring</button>
        <button onclick="clearOutput()">Clear Console</button>
    </div>
    <div id="output" style="overflow-y: auto; height: calc(100vh - 250px); margin-bottom: 20px;"></div>

    <script>
        class BinanceTrader {
            constructor(apiKey, apiSecret) {
                this.apiKey = apiKey;
                this.apiSecret = apiSecret;
            }

            async getKlines(symbol, interval, limit) {
                const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
                console.log(`Fetching klines from Binance: ${url}`);
                const response = await fetch(url);
                return await response.json();
            }
        }

        class TradingPredictor {
            constructor(interval, symbol, apiKey, apiSecret) {
                this.interval = interval;
                this.symbol = symbol;
                this.binanceTrader = new BinanceTrader(apiKey, apiSecret);
                this.monitoring = false;
            }

        async getPrediction() {
            try {
                const klines = await this.binanceTrader.getKlines(this.symbol, this.interval, 200);
                if (!Array.isArray(klines) || klines.length === 0) {
                    throw new Error('Invalid klines data received');
                }
                const data = this.processKlines(klines);
                if (!data.close || data.close.length < 2) {
                    throw new Error('Insufficient price data');
                }
                
                const currentPrice = parseFloat(data.close[data.close.length - 1]);
                const prevPrice = parseFloat(data.close[data.close.length - 2]);
                
                // Calculate volume analysis
                const volumeSMA = this.calculateSMA(data.volume, 20);
                const currentVolumeRatio = data.volume[data.volume.length - 1] / volumeSMA[volumeSMA.length - 1];
                
                // Calculate RSI
                const rsi = this.calculateRSI(data.close);
                
                // Calculate MACD
                const macd = this.calculateMACD(data.close);
                
                // Detect patterns
                const patterns = this.detectPatterns(data, data.close.length - 1);
                
                let confidence = 0.1; // Base confidence level
                let prediction = 'hold';
                
                // Pattern-based predictions
                if ((patterns.bullishEngulfing || patterns.hammer) && currentVolumeRatio > 1.5) {
                    prediction = 'buy';
                    confidence += 0.35;
                } else if ((patterns.bearishEngulfing || patterns.shootingStar) && currentVolumeRatio > 1.5) {
                    prediction = 'sell';
                    confidence += 0.35;
                }

                // Volume breakout
                if (currentVolumeRatio > 2.0) {
                    if (currentPrice > prevPrice) {
                        prediction = 'buy';
                        confidence += 0.2;
                    } else {
                        prediction = 'sell';
                        confidence += 0.2;
                    }
                }

                // Doji analysis
                if (patterns.doji && currentVolumeRatio > 1.3) {
                    prediction = currentPrice > prevPrice ? 'buy' : 'sell';
                    confidence += 0.25;
                }

                // RSI signals
                if (rsi < 30 && prediction !== 'sell') {
                    prediction = 'buy';
                    confidence += 0.2;
                } else if (rsi > 70 && prediction !== 'buy') {
                    prediction = 'sell';
                    confidence += 0.2;
                }

                // MACD signals
                if (macd.macd > macd.signal && prediction !== 'sell') {
                    prediction = 'buy';
                    confidence += 0.15;
                } else if (macd.macd < macd.signal && prediction !== 'buy') {
                    prediction = 'sell';
                    confidence += 0.15;
                }

                confidence = Math.min(confidence, 1.0);

                return {
                    prediction,
                    confidence: Math.round(confidence * 100) / 100,
                    price: currentPrice,
                    priceChange: ((currentPrice - prevPrice) / prevPrice) * 100,
                    rsi: Math.round(rsi * 100) / 100,
                    macd: macd.macd,
                    patterns
                };
            } catch (error) {
                console.error('Error getting prediction:', error);
                return null;
            }
        }

        processKlines(klines) {
            return {
                open: klines.map(k => parseFloat(k[1])),
                high: klines.map(k => parseFloat(k[2])),
                low: klines.map(k => parseFloat(k[3])),
                close: klines.map(k => parseFloat(k[4])),
                volume: klines.map(k => parseFloat(k[5]))
            };
        }

        calculateSMA(values, period) {
            const result = [];
            for (let i = period - 1; i < values.length; i++) {
                const sum = values.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                result.push(sum / period);
            }
            return result;
        }

        calculateRSI(prices, period = 14) {
            if (prices.length < period + 1) {
                return 50; // Default value when not enough data
            }

            const deltas = prices.slice(1).map((price, i) => price - prices[i]);
            const gains = deltas.map(d => d > 0 ? d : 0);
            const losses = deltas.map(d => d < 0 ? -d : 0);

            let avgGain = gains.slice(0, period).reduce((a, b) => a + b) / period;
            let avgLoss = losses.slice(0, period).reduce((a, b) => a + b) / period;

            // Calculate smoothed averages
            for (let i = period; i < gains.length; i++) {
                avgGain = (avgGain * (period - 1) + gains[i]) / period;
                avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
            }

            const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        }

        calculateMACD(prices) {
            const ema12 = this.calculateEMA(prices, 12);
            const ema26 = this.calculateEMA(prices, 26);
            const macdLine = ema12 - ema26;
            const signalLine = this.calculateEMA([macdLine], 9);
            
            return {
                macd: macdLine,
                signal: signalLine
            };
        }

        calculateEMA(prices, period) {
            const multiplier = 2 / (period + 1);
            let ema = prices[0];
            
            for (let i = 1; i < prices.length; i++) {
                ema = (prices[i] - ema) * multiplier + ema;
            }
            return ema;
        }

        detectPatterns(data, index) {
            const open = data.open[index];
            const close = data.close[index];
            const high = data.high[index];
            const low = data.low[index];
            const prevOpen = data.open[index - 1];
            const prevClose = data.close[index - 1];
            
            const body = Math.abs(close - open);
            const upperShadow = high - Math.max(open, close);
            const lowerShadow = Math.min(open, close) - low;
            
            return {
                doji: body <= (high - low) * 0.1,
                hammer: lowerShadow > body * 2 && upperShadow <= body * 0.1,
                shootingStar: upperShadow > body * 2 && lowerShadow <= body * 0.1,
                bullishEngulfing: close > open && prevClose < prevOpen && open < prevClose && close > prevOpen,
                bearishEngulfing: close < open && prevClose > prevOpen && open > prevClose && close < prevOpen
            };
        }
    }
        
        // Initialize predictor
        const predictor = new TradingPredictor(
            '1m', 
            'EURUSDT',
            'your-api-key',
            'your-api-secret'
        );

        function log(message, color = '') {
            const output = document.getElementById('output');
            output.innerHTML += `<div class="${color}">${message}</div>`;
            output.scrollTop = output.scrollHeight;
        }

        async function onDemandPrediction() {
            const prediction = await predictor.getPrediction();
            if (prediction) {
                displayPrediction(prediction);
            }
        }

        function displayPrediction(prediction) {
            if (!prediction) {
            log('<div class="error-message">⚠️ Error: Unable to generate prediction</div>', 'red');
            return;
            }

            const predictionClass = prediction.prediction === 'buy' ? 'buy-signal' : 'sell-signal';
            const confidenceLevel = prediction.confidence * 100;
            const confidenceEmoji = confidenceLevel > 70 ? '🌟' : confidenceLevel > 50 ? '✨' : '⚠️';

            const predictionCard = `
            <div class="prediction-card ${predictionClass}">
            <div class="card-header">
            <div class="timestamp" style="font-size: 0.8em;">🕒 ${new Date().toLocaleString()}</div>
            <div class="price-info">
            <span class="price-value">$${prediction.price.toFixed(4)}</span>
            </div>
            </div>
            <div class="main-prediction ${predictionClass}">
            ${prediction.prediction === 'buy' ? '📈' : '📉'} 
            ${prediction.prediction.toUpperCase()}
            </div>
            <div class="confidence">
            <div class="confidence-wrapper">
            <div class="confidence-bar" style="width: ${confidenceLevel}%">
            <span class="confidence-value">${confidenceLevel.toFixed(1)}%</span>
            </div>
            </div>
            </div>
            <div class="indicators-grid">
            <div class="indicator-box">RSI: ${prediction.rsi.toFixed(2)}</div>
            <div class="indicator-box">MACD: ${prediction.macd.toFixed(4)}</div>
            </div>
            <div class="patterns-grid">
            ${Object.entries(prediction.patterns)
            .filter(([,present]) => present)
            .map(([pattern]) => `
            <div class="pattern-item">
            ✅ ${pattern.replace(/([A-Z])/g, ' $1').trim()}
            </div>
            `).join('')}
            </div>
            </div>
            `;

            if (!document.querySelector('style#prediction-styles')) {
            const styles = `
            <style id="prediction-styles">
            .prediction-card {
            background: linear-gradient(145deg, #1a1a1a 0%, #2a2a2a 100%);
            border-radius: 10px;
            padding: 12px;
            margin: 10px 0;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4), 
                   0 2px 8px rgba(255, 255, 255, 0.1),
                   0 -2px 8px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
            }
            .prediction-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.5),
                   0 4px 12px rgba(255, 255, 255, 0.12),
                   0 -2px 12px rgba(0, 0, 0, 0.3);
            }
            .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            }
            .price-value {
            font-size: 1.2em;
            color: #2196F3;
            text-shadow: 0 0 8px rgba(33, 150, 243, 0.4);
            }
            .main-prediction {
            font-size: 1.5em;
            font-weight: bold;
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
            }
            .main-prediction.buy-signal {
            background: rgba(76, 175, 80, 0.1);
            color: #4CAF50;
            text-shadow: 0 0 8px rgba(76, 175, 80, 0.4);
            }
            .main-prediction.sell-signal {
            background: rgba(244, 67, 54, 0.1);
            color: #f44336;
            text-shadow: 0 0 8px rgba(244, 67, 54, 0.4);
            }
            .confidence-wrapper {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 2px;
            margin: 5px 0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
            }
            .confidence-bar {
            height: 16px;
            background: linear-gradient(90deg, #2196F3, #64B5F6);
            border-radius: 6px;
            position: relative;
            box-shadow: 0 2px 4px rgba(33, 150, 243, 0.3);
            }
            .confidence-value {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            color: white;
            font-size: 0.8em;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            }
            .indicators-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin: 8px 0;
            }
            .indicator-box {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            border-radius: 6px;
            font-size: 0.9em;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2),
                   inset 0 1px 2px rgba(255, 255, 255, 0.1);
            }
            .patterns-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
            }
            .pattern-item {
            background: rgba(33, 150, 243, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: transform 0.15s;
            }
            .pattern-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
            }
            </style>
            `;
            document.head.insertAdjacentHTML('beforeend', styles);
            }

            log(predictionCard);
        }

        let monitoringInterval;
        function toggleMonitoring() {
            const btn = document.getElementById('monitorBtn');
            if (predictor.monitoring) {
                predictor.monitoring = false;
                clearInterval(monitoringInterval);
                btn.textContent = 'Start Monitoring';
                
                showAndroidToast("Start Monitoring");
                btn.style.background = '#2a2a2a';
            } else {
                predictor.monitoring = true;
                btn.innerHTML = '<span class="spinner"></span> Monitoring...';
                btn.style.background = '#4CAF50';
                
                // Add loading spinner style if not already present
                if (!document.querySelector('style#spinnerStyle')) {
                    const style = document.createElement('style');
                    style.id = 'spinnerStyle';
                    style.textContent = `
                    .spinner {
                        display: inline-block;
                        width: 12px;
                        height: 12px;
                        border: 2px solid #ffffff;
                        border-top: 2px solid transparent;
                        border-radius: 50%;
                        animation: spin 1s linear infinite;
                        margin-right: 5px;
                    }
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }`;
                    document.head.appendChild(style);
                }

                monitoringInterval = setInterval(async () => {
                    // Add keep alive message
                    log('🔄 Checking for signals...', 'blue');
                    
                    const prediction = await predictor.getPrediction();
                    if (prediction && prediction.confidence > 0.35) {
                        // Send notification if supported
                        if ('Notification' in window && Notification.permission === 'granted') {
                            new Notification('Trading Signal', {
                                body: `${prediction.prediction.toUpperCase()} signal detected with ${prediction.confidence * 100}% confidence`
                            });
                        }
                        const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PurWcHEj+S1/LMeigJJHfH8N2QQAoUXrTp66hVDgtHn+DwsGEGHTqO1fPPcCoMIXXH8t+TPgoWXrLq7KpXDgxBnODysWIGHjmL1PTQcysNInTH89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTQcysNInTH89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcysNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcysNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcysNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcysNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcysNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcysNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcysNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcysNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcysNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcysNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcysNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcysNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcysNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcysNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcysNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcyoNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcyoNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcyoNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcyoNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcyoNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcyoNI3TG89+TPwoXXrLq7KpXDgxBnODysWIGHTmL1PTRcyoNI3TG89+TPwoXXrLq7KpXDgxBm+DysWIGHTmL1PTRcyoNI3TG89+TPwoXXrLq7KpXDgxBm+DysWIGHTmL1PTRcyoNI3TG89+TPwoXXrLq7KpXDgxBm+DysWIGHTmL1PTRcyoNI3TG89+TPwoXXrLq7KpXDgxBm+DysWIGHTmL1PTRcyoNI3TG89+TPwoXXrLq7KpXDgxBm+DysWIGHTmL1PTRcyoNI3TG89+TPwoXXrLq7KpXDgxBm+DysWIGHTmL1PTRcyoNI3TG89+TPwoXXrLq7KpXDgxBm+DysWIGHTmL1PTRcyoNI3TG89+TPwoXXrLq7KpXDgxBm+DysWIGHTmL1PTRcyoNI3TG89+TPwoXXrLq7KpXDgxBm+DysWIG');
                        audio.play();
                        displayPrediction(prediction);
                    }
                }, 10000);
            }
            
            // Request notification permission if not granted
            if ('Notification' in window && Notification.permission !== 'granted') {
                Notification.requestPermission();
            }
        }

        function clearOutput() {
            document.getElementById('output').innerHTML = '';
        }

        function showAndroidToast(toast) {
            try {
                if (AndroidInterface && typeof AndroidInterface.showToast === 'function') {
                    AndroidInterface.showToast(toast);
                } else {
                    console.log('AndroidInterface not available. Toast:', toast);
                }
            } catch (error) {
                console.error('Error showing toast:', error);
            }
        }
    </script>
</body>
</html>
